N = 5190368626345895934287890901269660368125784057648828856975240801692921413776935810951396636758593376464023732153808562577915326294549292556792318083456460414358670589558790144173739667282011259398806744613894933260508768164453285546138126203694294597933504055642697819621700254763734600344280501068177999525774852703392587283336207998442715798456209080653328127200872813609443749363227273699046384316916166626433575437021562049469208717054569553813263232081505031125527438753458933904315436901783224794196322766065164826925960773995214215381147347482542627866819917872550643128698349680648483832326897020480713274403
e = 4553946282291652052690658031871815044668666354631962857317064239937854154490666696656639431546546754075198244833269135807797859157266951509480243527385902331515096737432664289384232919597637219383873502574327223745605720595648738987401520533446827868921524368316060179185873369744485934713769475220677543716891526568051265350628642547523300233917866402687882040007757834115426271213394312182964844699999417105320248886751073056792470294958857459908439027648494157281427839954418509735172698475111787802398453598041627784527058640802255681509867982789549477590258901886115365415712131446464083391846938296637686141141
c = 4278309332156825513471133921767081679304964544859239167382013964027393751469199066006210224321932777921551197407888546951283928943909301823680246705259762244423567096675371219448090834663872616364574969641896444381678256471934928236713435926896440277035676194069165859614909016563308676279385215186547886609219204747472070664735444375639301428651340340780720127552991087751495266795976104346470986688608848835209931355307260301653286228948959844691360867014748176334479067393927459466554471471133896683038343406939197195079846015810013771357638816703241210434908838064251439569910777914016090367129105757847803108084
# try to find the 「flag」
# and don't forget to submit it to the platform
# numerator(n):分子, denominator(d)：分母
def t_cf(n, d):  # 将分数 x/y 转为连分数的形式
    res = []
    while d:
        res.append(n // d)
        n, d = d, n % d
    return res
def cf(sub_res):  # 得到渐进分数的分母和分子
    n, d = 1, 0
    for i in sub_res[::-1]:  # 从后面往前循环
        d, n = n, i * n + d
    return d, n
def list_fraction(x, y):  # 列出每个渐进分数
    res = t_cf(x, y)
    res = list(map(cf, (res[0:i] for i in range(1, len(res)))))  # 将连分数的结果逐一截取以求渐进分数
    return res
def get_pq(a, b, c):  # 由p+q和pq的值通过维达定理来求解p和q(解二元一次方程)
    par = math.isqrt(b * b - 4 * a * c)  # 由上述可得，开根号一定是整数，因为有解
    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)
    return x1, x2
def wienerAttack(e, n):
    for (d, k) in list_fraction(e, n):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if k == 0:  # 可能会出现连分数的第一个为0的情况，排除
            continue
        if (e * d - 1) % k != 0:  # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)
            continue

        phi = (e * d - 1) // k  # 这个结果就是 φ(n)

        px, qy = get_pq(1, n - phi + 1, n)

        if px * qy == n:
            p, q = abs(int(px)), abs(int(qy))  # 可能会得到两个负数，负负得正未尝不会出现
            d = invmod(e, (p - 1) * (q - 1))  # 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d
            return d
    print("求解d失败")
d=wienerAttack(e,N)
print(d)
flag=pow(c,d,N)
flag=n2s(flag).decode()
print(flag)
